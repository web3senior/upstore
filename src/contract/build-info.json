{
    "language": "Solidity",
    "sources": {
        "Upstore.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"_ownable.sol\";\n\n/// @title Upstore ðŸ†™\n/// @author Aratta Labs\n/// @notice Read the use cases\n/// @dev Please ensure that you run the test before deploying. You can find the deployed contract addresses in the README.md file.\n/// @custom:security-contact atenyun@gmail.com\ncontract Upstore is Ownable(msg.sender) {\n    using Counters for Counters.Counter;\n    Counters.Counter public _appCounter;\n    uint256 public price;\n\n    /// errors\n    error Unauthorized();\n    error PriceNotMet(uint256 price, uint256 amount);\n    error DuplicatedAddress(bytes32 appId, address sender);\n\n    // Events\n    event appAdded(address indexed sender, bytes32 indexed appId, string metadata, address indexed manager, bool status);\n    event likeAdded(address indexed sender, bytes32 indexed appId);\n    event Log(string func, uint256 gas);\n\n    struct AppStruct {\n        bytes32 id;\n        string metadata;\n        address manager;\n        uint256 dt;\n        bool status;\n    }\n\n    AppStruct[] public app;\n\n    struct LikeStruct {\n        bytes32 appId;\n        address sender;\n        uint256 dt;\n    }\n\n    LikeStruct[] public like;\n\n    mapping(bytes32 => mapping(bytes32 => string)) public blockStorage;\n\n    ///@dev Throws if called by any account other than the manager.\n    modifier onlyManager(bytes32 appId) {\n        uint256 appIndex = _indexOfApp(appId);\n        require(app[appIndex].manager == msg.sender, \"The sender is not the manager of the entered app ID.\");\n        _;\n    }\n\n    constructor() {\n        /// @dev Assert that count will start from 0\n        assert(_appCounter.current() == 0);\n        price = 1 ether;\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {\n        emit Log(\"fallback\", gasleft());\n    }\n\n    /// @notice Update the price\n    function setPrice(uint256 newPrice) public onlyOwner {\n        price = newPrice;\n    }\n\n    /// @notice Store a new key/ value\n    function setKey(\n        bytes32 appId,\n        bytes32 key,\n        string memory val\n    ) public onlyManager(appId) {\n        blockStorage[appId][key] = val;\n    }\n\n    /// @notice Get the stored value\n    /// @param appId The bytes32 ID\n    /// @param key A byte32 key\n    /// @return value in CID format\n    function getKey(bytes32 appId, bytes32 key) public view returns (string memory) {\n        return blockStorage[appId][key];\n    }\n\n    /// @notice Delete a key from the storage\n    /// @param appId The bytes32 ID\n    /// @param key A byte32 key\n    /// @return boolean\n    function delKey(bytes32 appId, bytes32 key) public onlyManager(appId) returns (bool) {\n        delete blockStorage[appId][key];\n        return true;\n    }\n\n    /// @notice Add a new dApp\n    /// @dev If the manager field is left empty, the sender will be recognized as the manager\n    /// @param metadata (CID)\n    /// @return appId\n    function setApp(string memory metadata, address manager) public payable returns (bytes32 appId) {\n        /// @notice Continue if the sender is owner or msg.value met the price\n        if (msg.sender != owner()) {\n            if (msg.value < price) revert PriceNotMet(price, msg.value);\n        }\n\n        /// @notice Increase counter\n        _appCounter.increment();\n\n        /// @notice Store the new dApp fields\n        app.push(AppStruct(bytes32(_appCounter.current()), metadata, manager == address(0) ? msg.sender : manager, block.timestamp, msg.sender == owner() ? true : false));\n\n        /// @notice Emit that a new dApp has been added\n        emit appAdded(msg.sender, bytes32(_appCounter.current()), metadata, manager == address(0) ? msg.sender : manager, msg.sender == owner() ? true : false);\n\n        return bytes32(_appCounter.current());\n    }\n\n    /// @notice get app detail\n    /// @param appId The unique bytes32 ID\n    /// @return AppStruct\n    function getApp(bytes32 appId) public view returns (AppStruct memory) {\n        for (uint256 i = 0; i < app.length; i++) if (app[i].id == appId && app[i].status) return app[i];\n\n        revert(\"The dAppId entered has not been declared or approved yet.\");\n    }\n\n    /// @notice Like an app\n    /// @dev A like per address\n    /// @param appId The bytes32 ID\n    /// @return bool\n    function setLike(bytes32 appId) public returns (bool) {\n        uint256 appIndex = _indexOfApp(appId);\n\n        for (uint256 i = 0; i < like.length; i++) if (like[i].sender == msg.sender && like[i].appId == appId && msg.sender != owner()) revert DuplicatedAddress(appId, msg.sender);\n\n        // Add new like\n        like.push(LikeStruct(app[appIndex].id, msg.sender, block.timestamp));\n\n        emit likeAdded(msg.sender, appId);\n\n        return true;\n    }\n\n    /// @notice Get total like\n    /// @param appId The bytes32 ID\n    /// @return uint256\n    function getLikeTotal(bytes32 appId) public view returns (uint256) {\n        uint256 counter = 0;\n        for (uint256 i = 0; i < like.length; i++) if (like[i].appId == appId) counter++;\n        return counter;\n    }\n\n    // check if sender is the manager of the UPstore\n    // returns boolean\n    function updateMetadata(bytes32 appId, string memory metadata) public onlyManager(appId) returns (bool) {\n        uint256 appIndex = _indexOfApp(appId);\n        app[appIndex].metadata = metadata;\n        return true;\n    }\n\n    /// @notice Display or hide the dApp from the store\n    /// @dev Only the owner of this contract can call/ aprove the dApp\n    /// @param appId The bytes32 ID\n    /// @return boolean\n    function updateApp(\n        bytes32 appId,\n        string memory metadata,\n        address manager\n    ) public onlyOwner returns (bool) {\n        uint256 appIndex = _indexOfApp(appId);\n        app[appIndex].metadata = metadata;\n        app[appIndex].manager = manager;\n        return true;\n    }\n\n    /// @notice  Number of apps currently added on the contract\n    /// @return uint256\n    function getAppTotal() public view returns (uint256) {\n        return app.length;\n    }\n\n    /// @notice Verify if a address is on a manager\n    /// @return appId\n    function verifyManager(bytes32 appId, address manager) public view returns (AppStruct memory) {\n        uint256 appIndex = _indexOfApp(appId);\n        if (app[appIndex].manager == manager) return app[appIndex];\n\n        revert(\"The manager address for the app ID you entered has not been determined.\");\n    }\n\n    /// @notice Display or hide the dApp from the store\n    /// @dev Only the owner of this contract can call/ aprove the dApp\n    /// @param appId The bytes32 ID\n    /// @return status\n    function toggleStatus(bytes32 appId) public onlyOwner returns (bool status) {\n        uint256 appIndex = _indexOfApp(appId);\n        return app[appIndex].status = !app[appIndex].status;\n    }\n\n    /// @notice Retrive the App array\n    /// @dev Returns the App array as AppStruct\n    /// @return AppStruct\n    /// @return total\n    function getAppList() public view returns (AppStruct[] memory, uint256 total) {\n        return (app, app.length);\n    }\n\n    /// @notice Retrive the App array\n    /// @dev Like[] starts from 0 to its length, a way to fetch all and filter it\n    /// @return total\n    function getLikeTotal() public view returns (uint256 total) {\n        return like.length;\n    }\n\n    /// @dev Retrieve the index of the app\n    /// @param appId The bytes32 ID\n    /// @return uint256\n    function _indexOfApp(bytes32 appId) internal view returns (uint256) {\n        for (uint256 i = 0; i < app.length; i++) if (app[i].id == appId) return i;\n        revert(\"App Id Not Found\");\n    }\n\n    // Function to withdraw all Ether from this contract.\n    function withdraw() public onlyOwner {\n        // get the amount of Ether stored in this contract\n        uint256 amount = address(this).balance;\n\n        // send all Ether to owner\n        (bool success, ) = owner().call{value: amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    // Function to transfer Ether from this contract to address from input\n    function transfer(address payable _to, uint256 _amount) public onlyOwner {\n        // Note that \"to\" is declared as payable\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    /// @notice Get contract's balance\n    function getBalance() public view onlyOwner returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
        },
        "_ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.24;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
        },
        "@openzeppelin/contracts/utils/Counters.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        },
        "remappings": []
    }
}